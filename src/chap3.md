# 3章 多重キュビット

## 3.1

- 多重キュビットはブロッホ球では表わせない
- 円表示ではNキュビットを \\(2^N\\) 個の円で表せる
- 図3-2の下から上へは  
  \\[
    (\ket{0}_3+\ket{1}_3) ({1\over\sqrt{2}}\ket{0}_2+{1\over\sqrt{2}}\ket{1}_2) ({1\over\sqrt{2}}\ket{0}_1+{1\over\sqrt{2}}\ket{1}_1) \\\\
    = {1\over 2}\ket{0}_3\ket{0}_2\ket{0}_1 + {1\over 2}\ket{0}_3\ket{0}_2\ket{1}_1 + \cdots
  \\]  
  ただし、下添字はキュビットを表し、\\( \ket{0}:=\ket{0}_3\ket{0}_2\ket{0}_1, \cdots, \ket{7}:=\ket{1}_3\ket{1}_2\ket{1}_1 \\)  
  上から下へは難しそう (因数分解っぽい?)。
- <https://oreilly-qc.github.io/?p=3-1>  
  で、 `qc.reset(3)` はレジスタを準備して、 `qint.new(1, 'qubit 1')` でレジスタを qint に割りあてている。普通のプログラミングではアセンブラを書いたりしない限りレジスタのことを考えないが、少なくともこのシミュレータではそうなっている。
- もつれた多重キュビットの状態は各キュビットの組み合わせで表現できず、単一キュビットの演算からもつれた状態を生成することもできない  
  図3-3 は3キュビットの場合だが、2キュビットの場合以下のようになる。   
  \\(\ket{0}+\ket{3}\\) を2キュビットの組み合わせで書けるとすると、  
  \\[ a,b,c,d \in \mathbb{C} \\\\
      (a\ket{0}_2 + b\ket{1}_2) (c\ket{0}_1+d\ket{1}_1) \\\\
      = ac\ket{0}_2\ket{0}_1 + ad\ket{0}_2\ket{1}_1 +  bc\ket{1}_2\ket{0}_1 +bd\ket{1}_2\ket{1}_1 \\\\
      = ac\ket{0} + ad\ket{1} + bc\ket{2} + bd\ket{3}
  \\]  
  と表すことができることになる。これが \\(\ket{0}+\ket{3}\\) と等しいためには、  
  \\(ac=bd=1\\) かつ \\(ad=bc=0\\) が必要だが、これは矛盾する。(証明 by ふぇるみうむ氏)

### 3.2

- レジスタが16進数で書いてあるけど実質2進数なのややこしい (訳注ありがたい)
- なぜ0はじまりではないのか

### 3.3

- N番目のキュビットに対する単一キュビット演算 (NOT, PHASE, HAD)は、円表示ではN個離れた「演算対象ペア」の円に適用される
- READ の場合、「演算対象ペア」の左側を半径を2乗して足し上げると出力が0になる確率。右側が1
